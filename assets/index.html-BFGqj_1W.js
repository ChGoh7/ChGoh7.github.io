import{_ as s,c as i,o as a,d as l}from"./app-CrMOoZ_k.js";const n={},e=l(`<ul><li>表示程序中可重复使用的一段代码集合可完成独立的功能</li></ul><h2 id="方法定义的格式" tabindex="-1"><a class="header-anchor" href="#方法定义的格式"><span>方法定义的格式</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">修饰符</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 返回值类型 方法名</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">([</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">参数类型 形参 </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 参数类型 形参 </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...])</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 方法体;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    [</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> 返回值</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">];</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 当方法需要给调用者返回值时</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当方法无返回值时，<strong>必须</strong>给出返回类型 <code>void</code></li><li>参数列表 / 参数清单，包含参数的个数、参数类型、 参数顺序</li><li><strong>方法签名</strong>：方法名 + 方法参数列表，判断是否是同一个方法的标准</li><li>在同一个类中，<strong>方法签名是唯一的</strong>，否则编译报错</li><li>考虑当调用者传入数据的<strong>范围</strong>不合理时，该如何处理（进行参数校验）</li></ul><h2 id="方法定义的位置" tabindex="-1"><a class="header-anchor" href="#方法定义的位置"><span>方法定义的位置</span></a></h2><ul><li>在类中，其它方法之外</li><li>方法之间声明顺序无规定</li></ul><h2 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用"><span>方法的调用</span></a></h2><ul><li>main 方法由 JVM 来调用</li><li>使用 <code>static</code>修饰的方法：属于这个类本身，方法所在类名.方法名([实参 1, 实参 2, …])</li><li>无<code>static</code>修饰的方法：属于该类的对象，不属于这个类本身，使用方法所在类的<strong>对象</strong>来调用，对象.方法名([实参 1, 实参 2, …])</li><li>针对于有返回的方法，调用者可以用对应类型的变量去接收返回值，<strong>也可以不去接收</strong></li></ul><h2 id="方法重载-overload" tabindex="-1"><a class="header-anchor" href="#方法重载-overload"><span>方法重载 Overload</span></a></h2><h3 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h3><p>解决了在同一个类中相同功能由于参数列表不同造成<strong>方法名不同</strong>的问题</p><h3 id="规则" tabindex="-1"><a class="header-anchor" href="#规则"><span>规则</span></a></h3><ul><li>两同：同类中，方法名相同</li><li>一不同：方法<strong>参数列表不同</strong></li></ul><p>注意：方法重载<strong>与方法的返回值类型、修饰符无关</strong></p><h2 id="方法参数的值传递机制" tabindex="-1"><a class="header-anchor" href="#方法参数的值传递机制"><span>方法参数的值传递机制</span></a></h2><p>方法被调用时，方法里的参数是以<strong>值传递</strong>的方式传递的，即传递的是实参的<strong>副本</strong></p><ul><li>参数是基本数据类型：直接传递<strong>实参值</strong>的副本</li><li>参数是引用数据类型，传递的是实参<strong>所引用的十六进制地址值</strong>的副本</li></ul><h2 id="形参个数可变的方法" tabindex="-1"><a class="header-anchor" href="#形参个数可变的方法"><span>形参个数可变的方法</span></a></h2><blockquote><p>也叫可变参数</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 与 getSum(int[] arr) 的方法签名相同</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getSum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">...</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> arr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 操作 arr 数组</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 调用 getSum</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> sum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getSum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> sum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> getSum</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>定义方法时，在<strong>最后一个形参的类型后</strong>增加三点（…），表明该形参可以接受多个参数值</li><li>作用：调用者不用创建数组；调用时对应的实参可以没有（动态初始化一个数组长度为 0 的数组进行传递）</li><li>本质就是一个数组参数：底层，在调用该方法的时候，用对应的实参作为元素创建一个数组，再将该数组传递给形参</li><li>注意：一个方法最多只有一个可变参数，必须放在参数列表最后</li></ul><h2 id="递归方法" tabindex="-1"><a class="header-anchor" href="#递归方法"><span>递归方法</span></a></h2><ul><li>一个方法的方法体实现中再次调用了方法本身</li><li>递归一定要向<strong>已知方向</strong>递归</li></ul>`,23),t=[e];function h(r,d){return a(),i("div",null,t)}const p=s(n,[["render",h],["__file","index.html.vue"]]),c=JSON.parse(`{"path":"/notes/JavaSE/p7kpg76z/","title":"04 方法","lang":"zh-CN","frontmatter":{"title":"04 方法","createTime":"2024/08/26 14:57:10","permalink":"/notes/JavaSE/p7kpg76z/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"方法定义的格式","slug":"方法定义的格式","link":"#方法定义的格式","children":[]},{"level":2,"title":"方法定义的位置","slug":"方法定义的位置","link":"#方法定义的位置","children":[]},{"level":2,"title":"方法的调用","slug":"方法的调用","link":"#方法的调用","children":[]},{"level":2,"title":"方法重载 Overload","slug":"方法重载-overload","link":"#方法重载-overload","children":[{"level":3,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":3,"title":"规则","slug":"规则","link":"#规则","children":[]}]},{"level":2,"title":"方法参数的值传递机制","slug":"方法参数的值传递机制","link":"#方法参数的值传递机制","children":[]},{"level":2,"title":"形参个数可变的方法","slug":"形参个数可变的方法","link":"#形参个数可变的方法","children":[]},{"level":2,"title":"递归方法","slug":"递归方法","link":"#递归方法","children":[]}],"readingTime":{"minutes":2.57,"words":771},"git":{"createdTime":1724666056000,"updatedTime":1724738849000,"contributors":[{"name":"chgoh7","email":"3180349973@qq.com","commits":2}]},"filePathRelative":"notes/JavaSE/01 基础/04 方法.md"}`);export{p as comp,c as data};
