import{_ as e,c as a,o as s,b as t}from"./app-COX0dHJ3.js";const i={},n=t('<ul><li>表示程序中可重复使用的一段代码集合可完成独立的功能</li></ul><h1 id="方法定义的格式" tabindex="-1"><a class="header-anchor" href="#方法定义的格式"><span>方法定义的格式</span></a></h1><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>[修饰符] 返回值类型 方法名([参数类型 形参 1, 参数类型 形参 2, ...]) {    // 方法体;    [return 返回值]; // 当方法需要给调用者返回值时}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>当方法无返回值时，<strong>必须</strong>给出返回类型 <code>void</code></li><li>参数列表 / 参数清单，包含参数的个数、参数类型、 参数顺序</li><li><strong>方法签名</strong>：方法名 + 方法参数列表，判断是否是同一个方法的标准</li><li>在同一个类中，<strong>方法签名是唯一的</strong>，否则编译报错</li><li>考虑当调用者传入数据的<strong>范围</strong>不合理时，该如何处理（进行参数校验）</li></ul><h1 id="方法定义的位置" tabindex="-1"><a class="header-anchor" href="#方法定义的位置"><span>方法定义的位置</span></a></h1><ul><li>在类中，其它方法之外</li><li>方法之间声明顺序无规定</li></ul><h1 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用"><span>方法的调用</span></a></h1><ul><li>main 方法由 JVM 来调用</li><li>使用 <code>static</code>修饰的方法：属于这个类本身，方法所在类名.方法名([实参 1, 实参 2, …])</li><li>无<code>static</code>修饰的方法：属于该类的对象，不属于这个类本身，使用方法所在类的<strong>对象</strong>来调用，对象.方法名([实参 1, 实参 2, …])</li><li>针对于有返回的方法，调用者可以用对应类型的变量去接收返回值，<strong>也可以不去接收</strong></li></ul><h1 id="方法重载-overload" tabindex="-1"><a class="header-anchor" href="#方法重载-overload"><span>方法重载 Overload</span></a></h1><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h2><p>解决了在同一个类中相同功能由于参数列表不同造成<strong>方法名不同</strong>的问题</p><h2 id="规则" tabindex="-1"><a class="header-anchor" href="#规则"><span>规则</span></a></h2><ul><li>两同：同类中，方法名相同</li><li>一不同：方法<strong>参数列表不同</strong></li></ul><p>注意：方法重载<strong>与方法的返回值类型、修饰符无关</strong></p><h1 id="方法参数的值传递机制" tabindex="-1"><a class="header-anchor" href="#方法参数的值传递机制"><span>方法参数的值传递机制</span></a></h1><p>方法被调用时，方法里的参数是以<strong>值传递</strong>的方式传递的，即传递的是实参的<strong>副本</strong></p><ul><li>参数是基本数据类型：直接传递<strong>实参值</strong>的副本</li><li>参数是引用数据类型，传递的是实参<strong>所引用的十六进制地址值</strong>的副本</li></ul><h1 id="形参个数可变的方法" tabindex="-1"><a class="header-anchor" href="#形参个数可变的方法"><span>形参个数可变的方法</span></a></h1><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>// 与 getSum(int[] arr) 的方法签名相同static int getSum(int... arr) {    // 操作 arr 数组}// 调用 getSumint sum = getSum(1, 2, 3, 4);int sum = getSum();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>定义方法时，在<strong>最后一个形参的类型后</strong>增加三点（…），表明该形参可以接受多个参数值</li><li>作用：调用者不用创建数组；调用时对应的实参可以没有（动态初始化一个数组长度为 0 的数组进行传递）</li><li>本质就是一个数组参数：底层，在调用该方法的时候，用对应的实参作为元素创建一个数组，再将该数组传递给形参</li><li>注意：一个方法最多只有一个可变参数，必须放在参数列表最后</li></ul><h1 id="递归方法" tabindex="-1"><a class="header-anchor" href="#递归方法"><span>递归方法</span></a></h1><ul><li>一个方法的方法体实现中再次调用了方法本身</li><li>递归一定要向<strong>已知方向</strong>递归</li></ul>',22),l=[n];function r(o,d){return s(),a("div",null,l)}const h=e(i,[["render",r],["__file","index.html.vue"]]),p=JSON.parse(`{"path":"/notes/JavaSE/p7kpg76z/","title":"04 方法","lang":"zh-CN","frontmatter":{"title":"04 方法","createTime":"2024/08/26 14:57:10","permalink":"/notes/JavaSE/p7kpg76z/","head":[["script",{"id":"check-dark-mode"},";(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();"],["script",{"id":"check-mac-os"},"document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))"]]},"headers":[{"level":2,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":2,"title":"规则","slug":"规则","link":"#规则","children":[]}],"readingTime":{"minutes":2.54,"words":762},"git":{"createdTime":1724666056000,"updatedTime":1724666056000,"contributors":[{"name":"chgoh7","email":"3180349973@qq.com","commits":1}]},"filePathRelative":"notes/JavaSE/01 基础/04 方法.md"}`);export{h as comp,p as data};
